## 接口 mock
因为还没有接口，请在 code/src/api/index.ts 中 mock 一些数据返回

1. 不直接发请求
2. 直接返回 mock 数据
3. 每次请求时 mock 数据有一定变化

## UI
目前未处理 UI，请依照 tasks/需求说明.md 中模块对应的图片严格处理实现 UI

## 2024-12-17: 添加 Activities 组件

### 需求
在首页的 DailyRequest 组件下方添加 Activities 组件，展示用户活动记录。

### 实现内容
1. 创建了新的 Activities 组件 (`code/src/components/activities/index.tsx`)
   - 展示标题 "Activity" 配合时钟图标
   - 右上角显示 "See more" 链接，点击跳转到积分记录页面
   - 显示活动列表，每项包含：
     - 活动标题（如 "Buy/sell crypto"）
     - 时间戳（如 "9:00 AM"）
     - 获得的积分（绿色显示，带 + 号）
   - 当前使用 mock 数据展示 3 条活动记录
   
2. 在首页 (`code/src/pages/home/index.tsx`) 中引入并使用 Activities 组件
   - 引入组件
   - 在 DailyRequest 下方添加 `<Activities />` 组件

### UI 设计
- 背景色：#201D1B
- 圆角：16px
- 标题字体：600 / 18px / #FAFAF9
- 活动标题字体：500 / 16px / #FAFAF9
- 时间字体：400 / 14px / #79716B
- 积分字体：600 / 20px / #47CD89（绿色）
- "See more" 字体：400 / 14px / #79716B

### 完成状态
✅ 已完成，无 linter 错误

## 2024-12-17: Activities 组件 UI 改进

### 需求
按照设计规范改进 Activities 组件的 UI：
- 宽度改为 100% - 40px（左右各留 20px）
- 容器居中显示
- 参考其他组件的布局方式
- 严格按照 Figma 设计规范调整样式

### 实现内容
1. **容器布局调整**
   - 宽度：`calc(100% - 40px)`
   - 居中：`margin: 0 auto`
   - 内边距：`padding: 16px 20px`
   - 间距：`gap: 16px`

2. **标题区域 (Header)**
   - 布局：`justify-content: space-between`
   - 标题字体：600 / 20px（原 18px）
   - 标题颜色：#FAFAF9
   - Icon 与文字间距：6px
   - See more 颜色：#838C9C（原 #79716B）
   - See more 字体：400 / 14px
   - 添加旋转的箭头图标

3. **卡片容器 (Cards)**
   - 背景色：#1C1917（原 #201D1B）
   - 边框：0.5px solid #44403C
   - 圆角：12px
   - 内边距：8px 0px

4. **列表项 (Activity Items)**
   - 内边距：`padding: 12px 16px`（原 16px 0）
   - 标题字体：500 / 16px / #FAFAF9
   - 时间字体：400 / 12px / #79716B（原 14px）
   - 标题和时间间距：2px
   - 积分字体：500 / 14px / line-height 20px / #47CD89（原 600 / 20px）
   - 移除了列表项底部边框

5. **其他改进**
   - 移除了外层容器的 `my-[30px]` 类名
   - 移除了外层容器的背景色和圆角（只有卡片有背景）
   - 统一使用 Figma 规范的尺寸和间距
   - 修复了 linter 错误（移除未使用的 index 变量）

### 完成状态
✅ 已完成，无 linter 错误
✅ 符合 Figma 设计规范

## 2024-12-17: 移除 MyPoints 组件的 onClick 事件

### 需求
移除 MyPoints 组件的点击事件功能。

### 实现内容
1. **MyPoints 组件 (`code/src/components/my-points/index.tsx`)**
   - 从 `MyPointsProps` 接口中移除 `onClick?: () => void;` 属性
   - 从组件参数中移除 `onClick` 的解构
   - 移除根 div 的 `onClick={onClick}` 事件处理
   - 移除 `cursor-pointer` 和 `active:opacity-90 transition-opacity` 类名（不再需要点击交互样式）

2. **HomePage 组件 (`code/src/pages/home/index.tsx`)**
   - 移除 `import { useNavigate } from 'react-router-dom';` 导入
   - 移除 `const navigate = useNavigate();` 变量声明
   - 从 `<MyPoints>` 组件移除 `onClick={handlePointsClick}` 属性

### 完成状态
✅ 已完成，无 linter 错误
✅ MyPoints 组件不再响应点击事件

## 2024-12-17: Points Records 页面添加顶部导航栏

### 需求
在 Points Records（积分记录）页面添加顶部导航栏，包含返回按钮和 "History" 标题，点击返回按钮可以返回首页。

### 实现内容
1. **导入 useNavigate**
   - 添加 `import { useNavigate } from 'react-router-dom';`
   - 创建 navigate 实例和 handleBack 函数

2. **顶部导航栏**
   - 容器样式：
     - 背景色：#1C1917
     - 高度：56px
     - 内边距：16px 20px
     - 居中对齐，使用相对定位
   
   - 返回按钮（左侧）：
     - 位置：`position: absolute, left: 20px`
     - 使用向左箭头 SVG 图标
     - 颜色：#FAFAF9
     - 点击事件：返回首页 (`navigate('/')`)
     - 交互效果：`active:opacity-70`
   
   - 标题（居中）：
     - 文本："History"
     - 字体：Sora / 600 / 20px
     - 颜色：#FAFAF9

3. **页面结构调整**
   - 外层容器改为全宽度，包含顶部导航和内容区域
   - 内容区域保持原有样式：`width: calc(100% - 40px)`, 居中显示
   - 顶部 padding 从 50px 调整为 24px（顶部导航栏已占据空间）

### 完成状态
✅ 已完成，无 linter 错误
✅ 顶部导航栏显示正常
✅ 返回按钮功能正常

## 2024-12-17: Points Records 页面顶部导航栏 CSS 规范调整

### 需求
按照 Figma 设计规范调整顶部导航栏的样式。

### 实现内容
1. **容器样式调整**
   - 布局：`justify-content: space-between`（原 center，现在三列布局）
   - 内边距：`padding: 10px 20px`（原 16px 20px）
   - 高度：`48px`（原 56px）
   - 间距：`gap: 8px`

2. **左侧返回按钮**
   - 宽度/高度：24px x 24px
   - 使用 `flexShrink: 0` 防止压缩
   - 图标颜色：#D9D9D9（原 #FAFAF9）
   - 移除 `position: absolute`，改为 flex 布局

3. **中间标题**
   - 字体大小：18px（原 20px）
   - 颜色：#D9D9D9（原 #FAFAF9）
   - 保持 Sora 字体，600 权重

4. **右侧占位元素**
   - 添加隐藏的占位 div（`visibility: hidden`）
   - 宽度/高度：24px x 24px
   - 用于保持标题居中对齐

### 完成状态
✅ 已完成，无 linter 错误
✅ 符合 Figma 设计规范
✅ 标题完美居中

## 2024-12-17: 使用 WebFListView 包裹路由页面

### 需求
根据 [OpenWebF 文档](https://openwebf.com/en/docs/developer-guide/components/webf-listview)，使用 WebFListView 组件包裹两个路由页面（HomePage 和 PointsRecordsPage），提供性能优化的列表渲染和下拉刷新、无限滚动功能。

### 实现内容

#### 1. 创建 WebFListView 组件 (`code/src/components/webf-listview/index.tsx`)
- 创建了本地 WebFListView 实现，用于开发环境
- 支持下拉刷新功能（Pull to Refresh）
- 支持无限滚动/加载更多（Load More）
- 触摸手势支持，可检测下拉距离
- 自动触发加载更多（滚动到底部时）
- 包含刷新状态指示器

**核心功能：**
- `onRefresh` - 下拉刷新回调
- `onLoadmore` - 滚动到底部加载更多回调
- `refresh-style` - 刷新样式（支持 "customCupertino"）
- 触摸手势检测和距离计算
- 平滑的刷新动画效果

#### 2. HomePage 集成 WebFListView (`code/src/pages/home/index.tsx`)
- 导入 WebFListView 组件
- 使用 WebFListView 包裹整个页面内容
- 添加 `handleRefresh` 函数，下拉时重新加载数据
- 设置 `refresh-style="customCupertino"` 使用 iOS 风格刷新
- 保持原有的所有组件和布局
- 移除外层 div，直接使用 WebFListView 作为根容器

**配置：**
```typescript
<WebFListView
  onRefresh={handleRefresh}
  refresh-style="customCupertino"
  style={{
    minHeight: '100vh',
    paddingBottom: '100px'
  }}
>
```

#### 3. PointsRecordsPage 集成 WebFListView (`code/src/pages/points-records/index.tsx`)
- 导入 WebFListView 和 useState
- 将 recordsData 改为 state 管理
- 添加 `handleRefresh` - 下拉刷新重置数据
- 添加 `handleLoadMore` - 滚动到底部加载更多历史记录
- WebFListView 包裹内容区域（顶部导航栏除外）
- 实现模拟加载更多：生成新的日期段和记录

**配置：**
```typescript
<WebFListView
  onRefresh={handleRefresh}
  onLoadmore={handleLoadMore}
  refresh-style="customCupertino"
  style={{
    flex: 1,
    width: '100%',
    overflow: 'auto'
  }}
>
```

**加载更多逻辑：**
- 模拟加载延迟 1 秒
- 生成新的日期段（05/07/2024）
- 添加新的记录到列表末尾
- 使用唯一 ID 避免 key 冲突

### WebFListView 优势
根据 [OpenWebF 文档](https://openwebf.com/en/docs/developer-guide/components/webf-listview)：

1. **性能优化** - 对长列表（100+ 项）提供优化渲染
2. **原生体验** - 原生下拉刷新，支持 Cupertino/Material 风格
3. **内存管理** - 更好的内存管理机制
4. **流畅滚动** - 移动设备上的流畅滚动性能
5. **开发便利** - 内置下拉刷新和无限滚动支持

### 注意事项
- 本地实现为开发环境使用
- 生产环境建议安装 `@openwebf/react-core-ui`
- WebFListView 需要设置固定高度或使用 flex 布局
- 下拉刷新需要在容器滚动位置为顶部时触发
- 加载更多在接近底部 50px 时自动触发

### 完成状态
✅ 已完成，无 linter 错误
✅ HomePage 支持下拉刷新
✅ PointsRecordsPage 支持下拉刷新和加载更多
✅ 创建本地 WebFListView 组件实现
✅ 符合 OpenWebF 最佳实践

## 2024-12-17: WebFListView 位置对比分析与修正

### 问题发现
对比两个页面的 WebFListView 使用位置，发现结构差异和潜在问题。

### 对比分析

#### HomePage 结构 ✅ **正确**
```
WebFListView (根容器)
└── 内容区域 (max-w-md)
    └── 所有组件
```

**特点：**
- WebFListView 是页面根容器
- 明确设置 `minHeight: '100vh'`
- 整个页面可滚动和下拉刷新
- 适用于无固定导航栏的页面

#### PointsRecordsPage 原结构 ⚠️ **存在问题**
```
外层 div (minHeight: 100vh)
├── 顶部导航栏 (48px)
└── WebFListView (flex: 1)
    └── 滚动内容
```

**问题：**
1. 外层容器使用 `minHeight: '100vh'` 而非 `height: '100vh'`
2. WebFListView 的 `flex: 1` 在 minHeight 容器中可能无法正确计算高度
3. 缺少 `overflow: hidden` 导致可能出现双重滚动条
4. 顶部导航栏缺少 `flexShrink: 0`

### 修正内容

#### 1. 外层容器修正
**修改前：**
```css
minHeight: '100vh',
paddingTop: "20px",
```

**修改后：**
```css
height: '100vh',
overflow: 'hidden'
```

**原因：**
- `height: '100vh'` 强制固定高度，确保 flex 子元素正确计算
- `overflow: 'hidden'` 防止页面级别的滚动，只在 WebFListView 内滚动
- 移除 `paddingTop`，由内部组件控制间距

#### 2. 顶部导航栏修正
**添加：**
```css
flexShrink: 0
```

**原因：**
- 防止导航栏在 flex 布局中被压缩
- 确保导航栏始终保持 48px 高度

#### 3. WebFListView 高度修正
**修改前：**
```css
flex: 1,
width: '100%',
overflow: 'auto'
```

**修改后：**
```css
flex: 1,
width: '100%',
height: 'calc(100vh - 48px)'
```

**原因：**
- 明确指定高度：视口高度减去导航栏高度
- 移除 `overflow: 'auto'`，由 WebFListView 内部处理
- 确保滚动容器有明确的高度约束

### 修正后的结构 ✅

#### PointsRecordsPage 新结构
```
外层 div (height: 100vh, overflow: hidden)
├── 顶部导航栏 (48px, flexShrink: 0)
└── WebFListView (flex: 1, height: calc(100vh - 48px))
    └── 滚动内容
```

### 两种布局模式总结

#### 模式 1: 全页面滚动（HomePage）
- 适用场景：无固定导航栏
- WebFListView 作为根容器
- 整个页面都可下拉刷新

#### 模式 2: 内容区域滚动（PointsRecordsPage）
- 适用场景：有固定导航栏
- WebFListView 只包裹内容区域
- 导航栏固定，内容区域滚动
- 需要明确的高度约束

### 最佳实践

根据 [OpenWebF 文档](https://openwebf.com/en/docs/developer-guide/components/webf-listview)：

1. **WebFListView 必须有明确的高度约束**
   - 使用 `height` 而非 `minHeight`
   - 或在 flex 容器中使用 `flex: 1` 且父容器有固定高度

2. **固定导航栏应在 WebFListView 外部**
   - 使用 `flexShrink: 0` 防止被压缩
   - 父容器使用 `overflow: hidden`

3. **避免双重滚动**
   - 页面级别不应有滚动
   - 只在 WebFListView 内部滚动

### 完成状态
✅ 已修正 PointsRecordsPage 布局问题
✅ 两个页面的 WebFListView 位置都正确
✅ 高度约束明确，滚动正常
✅ 符合最佳实践
✅ 无 linter 错误

## 2024-12-17: 基于 OpenWebF 官方示例改进路由系统

### 需求
参考 [OpenWebF 官方 Router 实现](https://github.com/openwebf/webf/blob/main/use_cases/src/router.tsx)，创建路由兼容层，使应用能够在 WebF 环境和浏览器环境中使用统一的路由 API。

### 实现内容

#### 1. 创建 WebF Router 兼容层 (`code/src/router/webf-router.tsx`)

基于 OpenWebF 官方示例实现了完整的路由兼容层，核心特性：

**环境检测：**
```typescript
const isWebF = typeof window !== 'undefined' && !!(window as any).webf;
```

**RouterProvider 组件：**
- WebF 环境：直接渲染子组件（使用 Flutter 原生路由）
- 浏览器环境：使用 `BrowserRouter` + `NavigatorRegistrar`
- 自动注册 navigate 函数供命令式导航使用

**统一的 Hooks：**
- `useParams` - 运行时自动选择正确实现
- `useLocation` - 获取当前路由信息

**统一的组件：**
- `Routes` - 路由容器组件
- `Route` - 单个路由定义
- `WebFRouterLink` - 兼容的链接组件

**WebFRouter API（命令式导航）：**
- `push(path, state?)` - 推入新路由
- `replace(path, state?)` - 替换当前路由
- `back()` - 返回上一页
- `pushState(state, path)` - 带状态推入
- `replaceState(state, path)` - 带状态替换
- `popAndPushNamed(path, state?)` - 弹出并推入
- `canPop()` - 检查是否可返回
- `maybePop(opts?)` - 尝试返回
- `restorablePopAndPushNamed(path, state?)` - 可恢复的导航

#### 2. 更新路由配置 (`code/src/router/index.tsx`)

**修改前（仅浏览器）：**
```typescript
import { createBrowserRouter } from 'react-router-dom';

export const router = createBrowserRouter([
  { path: '/', element: <HomePage /> },
  { path: '/points-records', element: <PointsRecordsPage /> },
]);
```

**修改后（兼容两种环境）：**
```typescript
import { Routes, Route } from './webf-router';

export function AppRoutes() {
  return (
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="/points-records" element={<PointsRecordsPage />} />
    </Routes>
  );
}

export { RouterProvider, WebFRouter, WebFRouterLink, useLocation, useParams, isWebFEnvironment } from './webf-router';
```

#### 3. 更新应用入口 (`code/src/App.tsx`)

**修改前：**
```typescript
import { RouterProvider } from 'react-router-dom';
import { router } from './router';

function App() {
  return <RouterProvider router={router} />;
}
```

**修改后：**
```typescript
import { RouterProvider, AppRoutes } from './router';

function App() {
  return (
    <RouterProvider>
      <AppRoutes />
    </RouterProvider>
  );
}
```

#### 4. 更新导航逻辑

**PointsRecordsPage (`code/src/pages/points-records/index.tsx`)：**
```typescript
// 修改前
import { useNavigate } from 'react-router-dom';
const navigate = useNavigate();
const handleBack = () => navigate('/');

// 修改后
import { WebFRouter } from '../../router';
const handleBack = () => WebFRouter.back();
```

**Activities 组件 (`code/src/components/activities/index.tsx`)：**
```typescript
// 修改前
import { useNavigate } from 'react-router-dom';
const navigate = useNavigate();
const handleSeeMore = () => navigate('/points-records');

// 修改后
import { WebFRouter } from '../../router';
const handleSeeMore = () => WebFRouter.push('/points-records');
```

#### 5. 创建路由文档 (`code/src/router/README.md`)

创建了详细的使用文档，包含：
- 特性介绍
- 环境支持说明
- 使用方法和示例
- 完整的 API 文档
- 迁移指南
- 最佳实践建议

### 技术亮点

#### 1. 运行时环境检测
```typescript
const isWebF = typeof window !== 'undefined' && !!(window as any).webf;
```
- 安全的环境检测
- 避免 SSR 环境错误

#### 2. 渐进式降级
```typescript
export const useParams = isWebF && WebFLib ? WebFLib.useParams : RRDUseParams;
```
- WebF 环境优先使用原生实现
- 浏览器环境自动回退到 react-router-dom

#### 3. 命令式导航桥接
```typescript
let navigateImpl: NavigateFn = (to, options) => { /* fallback */ };

const NavigatorRegistrar: React.FC = () => {
  const navigate = useNavigate();
  useEffect(() => {
    navigateImpl = (to, options) => navigate(to, options);
  }, [navigate]);
  return null;
};
```
- 在浏览器环境中注册 navigate 函数
- 使 WebFRouter API 能够工作

#### 4. 类型安全
```typescript
type NavigateFn = (to: string, options?: { replace?: boolean; state?: any }) => void;
type WebFRouterLinkProps = PropsWithChildren<{
  path: string;
  title?: string;
  onScreen?: () => void;
}>;
```
- 完整的 TypeScript 类型定义
- 确保编译时类型安全

### 优势对比

| 特性 | 改进前 | 改进后 |
|------|--------|--------|
| 环境支持 | 仅浏览器 | WebF + 浏览器 |
| API 统一性 | 使用 react-router-dom | 使用统一 API |
| 代码可移植性 | 低 | 高 |
| Flutter 集成 | 不支持 | 原生支持 |
| 导航方式 | useNavigate hook | WebFRouter API |
| 类型安全 | 部分 | 完整 |
| 文档完整性 | 无 | 详细文档 |

### 使用示例

#### 声明式路由
```tsx
import { Routes, Route } from './router';

<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/about" element={<About />} />
</Routes>
```

#### 命令式导航
```tsx
import { WebFRouter } from './router';

// 推入新路由
WebFRouter.push('/about');

// 返回上一页
WebFRouter.back();

// 带状态导航
WebFRouter.push('/profile', { userId: 123 });
```

#### 使用 Hooks
```tsx
import { useLocation, useParams } from './router';

function MyComponent() {
  const location = useLocation();
  const params = useParams();
}
```

#### 环境检测
```tsx
import { isWebFEnvironment } from './router';

if (isWebFEnvironment) {
  // WebF 特定逻辑
}
```

### 参考资源

- [OpenWebF 官方 Router 实现](https://github.com/openwebf/webf/blob/main/use_cases/src/router.tsx)
- [OpenWebF 文档](https://openwebf.com)
- [React Router 文档](https://reactrouter.com)

### 完成状态
✅ 已完成，无 linter 错误
✅ 创建完整的路由兼容层
✅ 更新所有路由配置和导航代码
✅ 支持 WebF 和浏览器双环境
✅ 提供统一的 API 接口
✅ 完整的类型安全
✅ 创建详细的使用文档
✅ 符合 OpenWebF 官方最佳实践